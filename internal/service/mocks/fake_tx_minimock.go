// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/ybgr111/chat-server/internal/service.FakeTx -o fake_tx_minimock.go -n FakeTxMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/jackc/pgconn"
	"github.com/jackc/pgx/v4"
)

// FakeTxMock implements service.FakeTx
type FakeTxMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcBegin          func(ctx context.Context) (t1 pgx.Tx, err error)
	inspectFuncBegin   func(ctx context.Context)
	afterBeginCounter  uint64
	beforeBeginCounter uint64
	BeginMock          mFakeTxMockBegin

	funcBeginFunc          func(ctx context.Context, f func(pgx.Tx) error) (err error)
	inspectFuncBeginFunc   func(ctx context.Context, f func(pgx.Tx) error)
	afterBeginFuncCounter  uint64
	beforeBeginFuncCounter uint64
	BeginFuncMock          mFakeTxMockBeginFunc

	funcCommit          func(ctx context.Context) (err error)
	inspectFuncCommit   func(ctx context.Context)
	afterCommitCounter  uint64
	beforeCommitCounter uint64
	CommitMock          mFakeTxMockCommit

	funcConn          func() (cp1 *pgx.Conn)
	inspectFuncConn   func()
	afterConnCounter  uint64
	beforeConnCounter uint64
	ConnMock          mFakeTxMockConn

	funcCopyFrom          func(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) (i1 int64, err error)
	inspectFuncCopyFrom   func(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource)
	afterCopyFromCounter  uint64
	beforeCopyFromCounter uint64
	CopyFromMock          mFakeTxMockCopyFrom

	funcExec          func(ctx context.Context, sql string, arguments ...interface{}) (commandTag pgconn.CommandTag, err error)
	inspectFuncExec   func(ctx context.Context, sql string, arguments ...interface{})
	afterExecCounter  uint64
	beforeExecCounter uint64
	ExecMock          mFakeTxMockExec

	funcLargeObjects          func() (l1 pgx.LargeObjects)
	inspectFuncLargeObjects   func()
	afterLargeObjectsCounter  uint64
	beforeLargeObjectsCounter uint64
	LargeObjectsMock          mFakeTxMockLargeObjects

	funcPrepare          func(ctx context.Context, name string, sql string) (sp1 *pgconn.StatementDescription, err error)
	inspectFuncPrepare   func(ctx context.Context, name string, sql string)
	afterPrepareCounter  uint64
	beforePrepareCounter uint64
	PrepareMock          mFakeTxMockPrepare

	funcQuery          func(ctx context.Context, sql string, args ...interface{}) (r1 pgx.Rows, err error)
	inspectFuncQuery   func(ctx context.Context, sql string, args ...interface{})
	afterQueryCounter  uint64
	beforeQueryCounter uint64
	QueryMock          mFakeTxMockQuery

	funcQueryFunc          func(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(pgx.QueryFuncRow) error) (c2 pgconn.CommandTag, err error)
	inspectFuncQueryFunc   func(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(pgx.QueryFuncRow) error)
	afterQueryFuncCounter  uint64
	beforeQueryFuncCounter uint64
	QueryFuncMock          mFakeTxMockQueryFunc

	funcQueryRow          func(ctx context.Context, sql string, args ...interface{}) (r1 pgx.Row)
	inspectFuncQueryRow   func(ctx context.Context, sql string, args ...interface{})
	afterQueryRowCounter  uint64
	beforeQueryRowCounter uint64
	QueryRowMock          mFakeTxMockQueryRow

	funcRollback          func(ctx context.Context) (err error)
	inspectFuncRollback   func(ctx context.Context)
	afterRollbackCounter  uint64
	beforeRollbackCounter uint64
	RollbackMock          mFakeTxMockRollback

	funcSendBatch          func(ctx context.Context, b *pgx.Batch) (b1 pgx.BatchResults)
	inspectFuncSendBatch   func(ctx context.Context, b *pgx.Batch)
	afterSendBatchCounter  uint64
	beforeSendBatchCounter uint64
	SendBatchMock          mFakeTxMockSendBatch
}

// NewFakeTxMock returns a mock for service.FakeTx
func NewFakeTxMock(t minimock.Tester) *FakeTxMock {
	m := &FakeTxMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.BeginMock = mFakeTxMockBegin{mock: m}
	m.BeginMock.callArgs = []*FakeTxMockBeginParams{}

	m.BeginFuncMock = mFakeTxMockBeginFunc{mock: m}
	m.BeginFuncMock.callArgs = []*FakeTxMockBeginFuncParams{}

	m.CommitMock = mFakeTxMockCommit{mock: m}
	m.CommitMock.callArgs = []*FakeTxMockCommitParams{}

	m.ConnMock = mFakeTxMockConn{mock: m}

	m.CopyFromMock = mFakeTxMockCopyFrom{mock: m}
	m.CopyFromMock.callArgs = []*FakeTxMockCopyFromParams{}

	m.ExecMock = mFakeTxMockExec{mock: m}
	m.ExecMock.callArgs = []*FakeTxMockExecParams{}

	m.LargeObjectsMock = mFakeTxMockLargeObjects{mock: m}

	m.PrepareMock = mFakeTxMockPrepare{mock: m}
	m.PrepareMock.callArgs = []*FakeTxMockPrepareParams{}

	m.QueryMock = mFakeTxMockQuery{mock: m}
	m.QueryMock.callArgs = []*FakeTxMockQueryParams{}

	m.QueryFuncMock = mFakeTxMockQueryFunc{mock: m}
	m.QueryFuncMock.callArgs = []*FakeTxMockQueryFuncParams{}

	m.QueryRowMock = mFakeTxMockQueryRow{mock: m}
	m.QueryRowMock.callArgs = []*FakeTxMockQueryRowParams{}

	m.RollbackMock = mFakeTxMockRollback{mock: m}
	m.RollbackMock.callArgs = []*FakeTxMockRollbackParams{}

	m.SendBatchMock = mFakeTxMockSendBatch{mock: m}
	m.SendBatchMock.callArgs = []*FakeTxMockSendBatchParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mFakeTxMockBegin struct {
	mock               *FakeTxMock
	defaultExpectation *FakeTxMockBeginExpectation
	expectations       []*FakeTxMockBeginExpectation

	callArgs []*FakeTxMockBeginParams
	mutex    sync.RWMutex
}

// FakeTxMockBeginExpectation specifies expectation struct of the FakeTx.Begin
type FakeTxMockBeginExpectation struct {
	mock    *FakeTxMock
	params  *FakeTxMockBeginParams
	results *FakeTxMockBeginResults
	Counter uint64
}

// FakeTxMockBeginParams contains parameters of the FakeTx.Begin
type FakeTxMockBeginParams struct {
	ctx context.Context
}

// FakeTxMockBeginResults contains results of the FakeTx.Begin
type FakeTxMockBeginResults struct {
	t1  pgx.Tx
	err error
}

// Expect sets up expected params for FakeTx.Begin
func (mmBegin *mFakeTxMockBegin) Expect(ctx context.Context) *mFakeTxMockBegin {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("FakeTxMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &FakeTxMockBeginExpectation{}
	}

	mmBegin.defaultExpectation.params = &FakeTxMockBeginParams{ctx}
	for _, e := range mmBegin.expectations {
		if minimock.Equal(e.params, mmBegin.defaultExpectation.params) {
			mmBegin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBegin.defaultExpectation.params)
		}
	}

	return mmBegin
}

// Inspect accepts an inspector function that has same arguments as the FakeTx.Begin
func (mmBegin *mFakeTxMockBegin) Inspect(f func(ctx context.Context)) *mFakeTxMockBegin {
	if mmBegin.mock.inspectFuncBegin != nil {
		mmBegin.mock.t.Fatalf("Inspect function is already set for FakeTxMock.Begin")
	}

	mmBegin.mock.inspectFuncBegin = f

	return mmBegin
}

// Return sets up results that will be returned by FakeTx.Begin
func (mmBegin *mFakeTxMockBegin) Return(t1 pgx.Tx, err error) *FakeTxMock {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("FakeTxMock.Begin mock is already set by Set")
	}

	if mmBegin.defaultExpectation == nil {
		mmBegin.defaultExpectation = &FakeTxMockBeginExpectation{mock: mmBegin.mock}
	}
	mmBegin.defaultExpectation.results = &FakeTxMockBeginResults{t1, err}
	return mmBegin.mock
}

// Set uses given function f to mock the FakeTx.Begin method
func (mmBegin *mFakeTxMockBegin) Set(f func(ctx context.Context) (t1 pgx.Tx, err error)) *FakeTxMock {
	if mmBegin.defaultExpectation != nil {
		mmBegin.mock.t.Fatalf("Default expectation is already set for the FakeTx.Begin method")
	}

	if len(mmBegin.expectations) > 0 {
		mmBegin.mock.t.Fatalf("Some expectations are already set for the FakeTx.Begin method")
	}

	mmBegin.mock.funcBegin = f
	return mmBegin.mock
}

// When sets expectation for the FakeTx.Begin which will trigger the result defined by the following
// Then helper
func (mmBegin *mFakeTxMockBegin) When(ctx context.Context) *FakeTxMockBeginExpectation {
	if mmBegin.mock.funcBegin != nil {
		mmBegin.mock.t.Fatalf("FakeTxMock.Begin mock is already set by Set")
	}

	expectation := &FakeTxMockBeginExpectation{
		mock:   mmBegin.mock,
		params: &FakeTxMockBeginParams{ctx},
	}
	mmBegin.expectations = append(mmBegin.expectations, expectation)
	return expectation
}

// Then sets up FakeTx.Begin return parameters for the expectation previously defined by the When method
func (e *FakeTxMockBeginExpectation) Then(t1 pgx.Tx, err error) *FakeTxMock {
	e.results = &FakeTxMockBeginResults{t1, err}
	return e.mock
}

// Begin implements service.FakeTx
func (mmBegin *FakeTxMock) Begin(ctx context.Context) (t1 pgx.Tx, err error) {
	mm_atomic.AddUint64(&mmBegin.beforeBeginCounter, 1)
	defer mm_atomic.AddUint64(&mmBegin.afterBeginCounter, 1)

	if mmBegin.inspectFuncBegin != nil {
		mmBegin.inspectFuncBegin(ctx)
	}

	mm_params := FakeTxMockBeginParams{ctx}

	// Record call args
	mmBegin.BeginMock.mutex.Lock()
	mmBegin.BeginMock.callArgs = append(mmBegin.BeginMock.callArgs, &mm_params)
	mmBegin.BeginMock.mutex.Unlock()

	for _, e := range mmBegin.BeginMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1, e.results.err
		}
	}

	if mmBegin.BeginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBegin.BeginMock.defaultExpectation.Counter, 1)
		mm_want := mmBegin.BeginMock.defaultExpectation.params
		mm_got := FakeTxMockBeginParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBegin.t.Errorf("FakeTxMock.Begin got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBegin.BeginMock.defaultExpectation.results
		if mm_results == nil {
			mmBegin.t.Fatal("No results are set for the FakeTxMock.Begin")
		}
		return (*mm_results).t1, (*mm_results).err
	}
	if mmBegin.funcBegin != nil {
		return mmBegin.funcBegin(ctx)
	}
	mmBegin.t.Fatalf("Unexpected call to FakeTxMock.Begin. %v", ctx)
	return
}

// BeginAfterCounter returns a count of finished FakeTxMock.Begin invocations
func (mmBegin *FakeTxMock) BeginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBegin.afterBeginCounter)
}

// BeginBeforeCounter returns a count of FakeTxMock.Begin invocations
func (mmBegin *FakeTxMock) BeginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBegin.beforeBeginCounter)
}

// Calls returns a list of arguments used in each call to FakeTxMock.Begin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBegin *mFakeTxMockBegin) Calls() []*FakeTxMockBeginParams {
	mmBegin.mutex.RLock()

	argCopy := make([]*FakeTxMockBeginParams, len(mmBegin.callArgs))
	copy(argCopy, mmBegin.callArgs)

	mmBegin.mutex.RUnlock()

	return argCopy
}

// MinimockBeginDone returns true if the count of the Begin invocations corresponds
// the number of defined expectations
func (m *FakeTxMock) MinimockBeginDone() bool {
	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBegin != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		return false
	}
	return true
}

// MinimockBeginInspect logs each unmet expectation
func (m *FakeTxMock) MinimockBeginInspect() {
	for _, e := range m.BeginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FakeTxMock.Begin with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		if m.BeginMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FakeTxMock.Begin")
		} else {
			m.t.Errorf("Expected call to FakeTxMock.Begin with params: %#v", *m.BeginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBegin != nil && mm_atomic.LoadUint64(&m.afterBeginCounter) < 1 {
		m.t.Error("Expected call to FakeTxMock.Begin")
	}
}

type mFakeTxMockBeginFunc struct {
	mock               *FakeTxMock
	defaultExpectation *FakeTxMockBeginFuncExpectation
	expectations       []*FakeTxMockBeginFuncExpectation

	callArgs []*FakeTxMockBeginFuncParams
	mutex    sync.RWMutex
}

// FakeTxMockBeginFuncExpectation specifies expectation struct of the FakeTx.BeginFunc
type FakeTxMockBeginFuncExpectation struct {
	mock    *FakeTxMock
	params  *FakeTxMockBeginFuncParams
	results *FakeTxMockBeginFuncResults
	Counter uint64
}

// FakeTxMockBeginFuncParams contains parameters of the FakeTx.BeginFunc
type FakeTxMockBeginFuncParams struct {
	ctx context.Context
	f   func(pgx.Tx) error
}

// FakeTxMockBeginFuncResults contains results of the FakeTx.BeginFunc
type FakeTxMockBeginFuncResults struct {
	err error
}

// Expect sets up expected params for FakeTx.BeginFunc
func (mmBeginFunc *mFakeTxMockBeginFunc) Expect(ctx context.Context, f func(pgx.Tx) error) *mFakeTxMockBeginFunc {
	if mmBeginFunc.mock.funcBeginFunc != nil {
		mmBeginFunc.mock.t.Fatalf("FakeTxMock.BeginFunc mock is already set by Set")
	}

	if mmBeginFunc.defaultExpectation == nil {
		mmBeginFunc.defaultExpectation = &FakeTxMockBeginFuncExpectation{}
	}

	mmBeginFunc.defaultExpectation.params = &FakeTxMockBeginFuncParams{ctx, f}
	for _, e := range mmBeginFunc.expectations {
		if minimock.Equal(e.params, mmBeginFunc.defaultExpectation.params) {
			mmBeginFunc.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmBeginFunc.defaultExpectation.params)
		}
	}

	return mmBeginFunc
}

// Inspect accepts an inspector function that has same arguments as the FakeTx.BeginFunc
func (mmBeginFunc *mFakeTxMockBeginFunc) Inspect(f func(ctx context.Context, f func(pgx.Tx) error)) *mFakeTxMockBeginFunc {
	if mmBeginFunc.mock.inspectFuncBeginFunc != nil {
		mmBeginFunc.mock.t.Fatalf("Inspect function is already set for FakeTxMock.BeginFunc")
	}

	mmBeginFunc.mock.inspectFuncBeginFunc = f

	return mmBeginFunc
}

// Return sets up results that will be returned by FakeTx.BeginFunc
func (mmBeginFunc *mFakeTxMockBeginFunc) Return(err error) *FakeTxMock {
	if mmBeginFunc.mock.funcBeginFunc != nil {
		mmBeginFunc.mock.t.Fatalf("FakeTxMock.BeginFunc mock is already set by Set")
	}

	if mmBeginFunc.defaultExpectation == nil {
		mmBeginFunc.defaultExpectation = &FakeTxMockBeginFuncExpectation{mock: mmBeginFunc.mock}
	}
	mmBeginFunc.defaultExpectation.results = &FakeTxMockBeginFuncResults{err}
	return mmBeginFunc.mock
}

// Set uses given function f to mock the FakeTx.BeginFunc method
func (mmBeginFunc *mFakeTxMockBeginFunc) Set(f func(ctx context.Context, f func(pgx.Tx) error) (err error)) *FakeTxMock {
	if mmBeginFunc.defaultExpectation != nil {
		mmBeginFunc.mock.t.Fatalf("Default expectation is already set for the FakeTx.BeginFunc method")
	}

	if len(mmBeginFunc.expectations) > 0 {
		mmBeginFunc.mock.t.Fatalf("Some expectations are already set for the FakeTx.BeginFunc method")
	}

	mmBeginFunc.mock.funcBeginFunc = f
	return mmBeginFunc.mock
}

// When sets expectation for the FakeTx.BeginFunc which will trigger the result defined by the following
// Then helper
func (mmBeginFunc *mFakeTxMockBeginFunc) When(ctx context.Context, f func(pgx.Tx) error) *FakeTxMockBeginFuncExpectation {
	if mmBeginFunc.mock.funcBeginFunc != nil {
		mmBeginFunc.mock.t.Fatalf("FakeTxMock.BeginFunc mock is already set by Set")
	}

	expectation := &FakeTxMockBeginFuncExpectation{
		mock:   mmBeginFunc.mock,
		params: &FakeTxMockBeginFuncParams{ctx, f},
	}
	mmBeginFunc.expectations = append(mmBeginFunc.expectations, expectation)
	return expectation
}

// Then sets up FakeTx.BeginFunc return parameters for the expectation previously defined by the When method
func (e *FakeTxMockBeginFuncExpectation) Then(err error) *FakeTxMock {
	e.results = &FakeTxMockBeginFuncResults{err}
	return e.mock
}

// BeginFunc implements service.FakeTx
func (mmBeginFunc *FakeTxMock) BeginFunc(ctx context.Context, f func(pgx.Tx) error) (err error) {
	mm_atomic.AddUint64(&mmBeginFunc.beforeBeginFuncCounter, 1)
	defer mm_atomic.AddUint64(&mmBeginFunc.afterBeginFuncCounter, 1)

	if mmBeginFunc.inspectFuncBeginFunc != nil {
		mmBeginFunc.inspectFuncBeginFunc(ctx, f)
	}

	mm_params := FakeTxMockBeginFuncParams{ctx, f}

	// Record call args
	mmBeginFunc.BeginFuncMock.mutex.Lock()
	mmBeginFunc.BeginFuncMock.callArgs = append(mmBeginFunc.BeginFuncMock.callArgs, &mm_params)
	mmBeginFunc.BeginFuncMock.mutex.Unlock()

	for _, e := range mmBeginFunc.BeginFuncMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmBeginFunc.BeginFuncMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmBeginFunc.BeginFuncMock.defaultExpectation.Counter, 1)
		mm_want := mmBeginFunc.BeginFuncMock.defaultExpectation.params
		mm_got := FakeTxMockBeginFuncParams{ctx, f}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmBeginFunc.t.Errorf("FakeTxMock.BeginFunc got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmBeginFunc.BeginFuncMock.defaultExpectation.results
		if mm_results == nil {
			mmBeginFunc.t.Fatal("No results are set for the FakeTxMock.BeginFunc")
		}
		return (*mm_results).err
	}
	if mmBeginFunc.funcBeginFunc != nil {
		return mmBeginFunc.funcBeginFunc(ctx, f)
	}
	mmBeginFunc.t.Fatalf("Unexpected call to FakeTxMock.BeginFunc. %v %v", ctx, f)
	return
}

// BeginFuncAfterCounter returns a count of finished FakeTxMock.BeginFunc invocations
func (mmBeginFunc *FakeTxMock) BeginFuncAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeginFunc.afterBeginFuncCounter)
}

// BeginFuncBeforeCounter returns a count of FakeTxMock.BeginFunc invocations
func (mmBeginFunc *FakeTxMock) BeginFuncBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmBeginFunc.beforeBeginFuncCounter)
}

// Calls returns a list of arguments used in each call to FakeTxMock.BeginFunc.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmBeginFunc *mFakeTxMockBeginFunc) Calls() []*FakeTxMockBeginFuncParams {
	mmBeginFunc.mutex.RLock()

	argCopy := make([]*FakeTxMockBeginFuncParams, len(mmBeginFunc.callArgs))
	copy(argCopy, mmBeginFunc.callArgs)

	mmBeginFunc.mutex.RUnlock()

	return argCopy
}

// MinimockBeginFuncDone returns true if the count of the BeginFunc invocations corresponds
// the number of defined expectations
func (m *FakeTxMock) MinimockBeginFuncDone() bool {
	for _, e := range m.BeginFuncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginFuncMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginFuncCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBeginFunc != nil && mm_atomic.LoadUint64(&m.afterBeginFuncCounter) < 1 {
		return false
	}
	return true
}

// MinimockBeginFuncInspect logs each unmet expectation
func (m *FakeTxMock) MinimockBeginFuncInspect() {
	for _, e := range m.BeginFuncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FakeTxMock.BeginFunc with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.BeginFuncMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterBeginFuncCounter) < 1 {
		if m.BeginFuncMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FakeTxMock.BeginFunc")
		} else {
			m.t.Errorf("Expected call to FakeTxMock.BeginFunc with params: %#v", *m.BeginFuncMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcBeginFunc != nil && mm_atomic.LoadUint64(&m.afterBeginFuncCounter) < 1 {
		m.t.Error("Expected call to FakeTxMock.BeginFunc")
	}
}

type mFakeTxMockCommit struct {
	mock               *FakeTxMock
	defaultExpectation *FakeTxMockCommitExpectation
	expectations       []*FakeTxMockCommitExpectation

	callArgs []*FakeTxMockCommitParams
	mutex    sync.RWMutex
}

// FakeTxMockCommitExpectation specifies expectation struct of the FakeTx.Commit
type FakeTxMockCommitExpectation struct {
	mock    *FakeTxMock
	params  *FakeTxMockCommitParams
	results *FakeTxMockCommitResults
	Counter uint64
}

// FakeTxMockCommitParams contains parameters of the FakeTx.Commit
type FakeTxMockCommitParams struct {
	ctx context.Context
}

// FakeTxMockCommitResults contains results of the FakeTx.Commit
type FakeTxMockCommitResults struct {
	err error
}

// Expect sets up expected params for FakeTx.Commit
func (mmCommit *mFakeTxMockCommit) Expect(ctx context.Context) *mFakeTxMockCommit {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("FakeTxMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &FakeTxMockCommitExpectation{}
	}

	mmCommit.defaultExpectation.params = &FakeTxMockCommitParams{ctx}
	for _, e := range mmCommit.expectations {
		if minimock.Equal(e.params, mmCommit.defaultExpectation.params) {
			mmCommit.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCommit.defaultExpectation.params)
		}
	}

	return mmCommit
}

// Inspect accepts an inspector function that has same arguments as the FakeTx.Commit
func (mmCommit *mFakeTxMockCommit) Inspect(f func(ctx context.Context)) *mFakeTxMockCommit {
	if mmCommit.mock.inspectFuncCommit != nil {
		mmCommit.mock.t.Fatalf("Inspect function is already set for FakeTxMock.Commit")
	}

	mmCommit.mock.inspectFuncCommit = f

	return mmCommit
}

// Return sets up results that will be returned by FakeTx.Commit
func (mmCommit *mFakeTxMockCommit) Return(err error) *FakeTxMock {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("FakeTxMock.Commit mock is already set by Set")
	}

	if mmCommit.defaultExpectation == nil {
		mmCommit.defaultExpectation = &FakeTxMockCommitExpectation{mock: mmCommit.mock}
	}
	mmCommit.defaultExpectation.results = &FakeTxMockCommitResults{err}
	return mmCommit.mock
}

// Set uses given function f to mock the FakeTx.Commit method
func (mmCommit *mFakeTxMockCommit) Set(f func(ctx context.Context) (err error)) *FakeTxMock {
	if mmCommit.defaultExpectation != nil {
		mmCommit.mock.t.Fatalf("Default expectation is already set for the FakeTx.Commit method")
	}

	if len(mmCommit.expectations) > 0 {
		mmCommit.mock.t.Fatalf("Some expectations are already set for the FakeTx.Commit method")
	}

	mmCommit.mock.funcCommit = f
	return mmCommit.mock
}

// When sets expectation for the FakeTx.Commit which will trigger the result defined by the following
// Then helper
func (mmCommit *mFakeTxMockCommit) When(ctx context.Context) *FakeTxMockCommitExpectation {
	if mmCommit.mock.funcCommit != nil {
		mmCommit.mock.t.Fatalf("FakeTxMock.Commit mock is already set by Set")
	}

	expectation := &FakeTxMockCommitExpectation{
		mock:   mmCommit.mock,
		params: &FakeTxMockCommitParams{ctx},
	}
	mmCommit.expectations = append(mmCommit.expectations, expectation)
	return expectation
}

// Then sets up FakeTx.Commit return parameters for the expectation previously defined by the When method
func (e *FakeTxMockCommitExpectation) Then(err error) *FakeTxMock {
	e.results = &FakeTxMockCommitResults{err}
	return e.mock
}

// Commit implements service.FakeTx
func (mmCommit *FakeTxMock) Commit(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmCommit.beforeCommitCounter, 1)
	defer mm_atomic.AddUint64(&mmCommit.afterCommitCounter, 1)

	if mmCommit.inspectFuncCommit != nil {
		mmCommit.inspectFuncCommit(ctx)
	}

	mm_params := FakeTxMockCommitParams{ctx}

	// Record call args
	mmCommit.CommitMock.mutex.Lock()
	mmCommit.CommitMock.callArgs = append(mmCommit.CommitMock.callArgs, &mm_params)
	mmCommit.CommitMock.mutex.Unlock()

	for _, e := range mmCommit.CommitMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmCommit.CommitMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCommit.CommitMock.defaultExpectation.Counter, 1)
		mm_want := mmCommit.CommitMock.defaultExpectation.params
		mm_got := FakeTxMockCommitParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCommit.t.Errorf("FakeTxMock.Commit got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCommit.CommitMock.defaultExpectation.results
		if mm_results == nil {
			mmCommit.t.Fatal("No results are set for the FakeTxMock.Commit")
		}
		return (*mm_results).err
	}
	if mmCommit.funcCommit != nil {
		return mmCommit.funcCommit(ctx)
	}
	mmCommit.t.Fatalf("Unexpected call to FakeTxMock.Commit. %v", ctx)
	return
}

// CommitAfterCounter returns a count of finished FakeTxMock.Commit invocations
func (mmCommit *FakeTxMock) CommitAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommit.afterCommitCounter)
}

// CommitBeforeCounter returns a count of FakeTxMock.Commit invocations
func (mmCommit *FakeTxMock) CommitBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCommit.beforeCommitCounter)
}

// Calls returns a list of arguments used in each call to FakeTxMock.Commit.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCommit *mFakeTxMockCommit) Calls() []*FakeTxMockCommitParams {
	mmCommit.mutex.RLock()

	argCopy := make([]*FakeTxMockCommitParams, len(mmCommit.callArgs))
	copy(argCopy, mmCommit.callArgs)

	mmCommit.mutex.RUnlock()

	return argCopy
}

// MinimockCommitDone returns true if the count of the Commit invocations corresponds
// the number of defined expectations
func (m *FakeTxMock) MinimockCommitDone() bool {
	for _, e := range m.CommitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommitCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommit != nil && mm_atomic.LoadUint64(&m.afterCommitCounter) < 1 {
		return false
	}
	return true
}

// MinimockCommitInspect logs each unmet expectation
func (m *FakeTxMock) MinimockCommitInspect() {
	for _, e := range m.CommitMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FakeTxMock.Commit with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CommitMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCommitCounter) < 1 {
		if m.CommitMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FakeTxMock.Commit")
		} else {
			m.t.Errorf("Expected call to FakeTxMock.Commit with params: %#v", *m.CommitMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCommit != nil && mm_atomic.LoadUint64(&m.afterCommitCounter) < 1 {
		m.t.Error("Expected call to FakeTxMock.Commit")
	}
}

type mFakeTxMockConn struct {
	mock               *FakeTxMock
	defaultExpectation *FakeTxMockConnExpectation
	expectations       []*FakeTxMockConnExpectation
}

// FakeTxMockConnExpectation specifies expectation struct of the FakeTx.Conn
type FakeTxMockConnExpectation struct {
	mock *FakeTxMock

	results *FakeTxMockConnResults
	Counter uint64
}

// FakeTxMockConnResults contains results of the FakeTx.Conn
type FakeTxMockConnResults struct {
	cp1 *pgx.Conn
}

// Expect sets up expected params for FakeTx.Conn
func (mmConn *mFakeTxMockConn) Expect() *mFakeTxMockConn {
	if mmConn.mock.funcConn != nil {
		mmConn.mock.t.Fatalf("FakeTxMock.Conn mock is already set by Set")
	}

	if mmConn.defaultExpectation == nil {
		mmConn.defaultExpectation = &FakeTxMockConnExpectation{}
	}

	return mmConn
}

// Inspect accepts an inspector function that has same arguments as the FakeTx.Conn
func (mmConn *mFakeTxMockConn) Inspect(f func()) *mFakeTxMockConn {
	if mmConn.mock.inspectFuncConn != nil {
		mmConn.mock.t.Fatalf("Inspect function is already set for FakeTxMock.Conn")
	}

	mmConn.mock.inspectFuncConn = f

	return mmConn
}

// Return sets up results that will be returned by FakeTx.Conn
func (mmConn *mFakeTxMockConn) Return(cp1 *pgx.Conn) *FakeTxMock {
	if mmConn.mock.funcConn != nil {
		mmConn.mock.t.Fatalf("FakeTxMock.Conn mock is already set by Set")
	}

	if mmConn.defaultExpectation == nil {
		mmConn.defaultExpectation = &FakeTxMockConnExpectation{mock: mmConn.mock}
	}
	mmConn.defaultExpectation.results = &FakeTxMockConnResults{cp1}
	return mmConn.mock
}

// Set uses given function f to mock the FakeTx.Conn method
func (mmConn *mFakeTxMockConn) Set(f func() (cp1 *pgx.Conn)) *FakeTxMock {
	if mmConn.defaultExpectation != nil {
		mmConn.mock.t.Fatalf("Default expectation is already set for the FakeTx.Conn method")
	}

	if len(mmConn.expectations) > 0 {
		mmConn.mock.t.Fatalf("Some expectations are already set for the FakeTx.Conn method")
	}

	mmConn.mock.funcConn = f
	return mmConn.mock
}

// Conn implements service.FakeTx
func (mmConn *FakeTxMock) Conn() (cp1 *pgx.Conn) {
	mm_atomic.AddUint64(&mmConn.beforeConnCounter, 1)
	defer mm_atomic.AddUint64(&mmConn.afterConnCounter, 1)

	if mmConn.inspectFuncConn != nil {
		mmConn.inspectFuncConn()
	}

	if mmConn.ConnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmConn.ConnMock.defaultExpectation.Counter, 1)

		mm_results := mmConn.ConnMock.defaultExpectation.results
		if mm_results == nil {
			mmConn.t.Fatal("No results are set for the FakeTxMock.Conn")
		}
		return (*mm_results).cp1
	}
	if mmConn.funcConn != nil {
		return mmConn.funcConn()
	}
	mmConn.t.Fatalf("Unexpected call to FakeTxMock.Conn.")
	return
}

// ConnAfterCounter returns a count of finished FakeTxMock.Conn invocations
func (mmConn *FakeTxMock) ConnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConn.afterConnCounter)
}

// ConnBeforeCounter returns a count of FakeTxMock.Conn invocations
func (mmConn *FakeTxMock) ConnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmConn.beforeConnCounter)
}

// MinimockConnDone returns true if the count of the Conn invocations corresponds
// the number of defined expectations
func (m *FakeTxMock) MinimockConnDone() bool {
	for _, e := range m.ConnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConnCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConn != nil && mm_atomic.LoadUint64(&m.afterConnCounter) < 1 {
		return false
	}
	return true
}

// MinimockConnInspect logs each unmet expectation
func (m *FakeTxMock) MinimockConnInspect() {
	for _, e := range m.ConnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FakeTxMock.Conn")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ConnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterConnCounter) < 1 {
		m.t.Error("Expected call to FakeTxMock.Conn")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcConn != nil && mm_atomic.LoadUint64(&m.afterConnCounter) < 1 {
		m.t.Error("Expected call to FakeTxMock.Conn")
	}
}

type mFakeTxMockCopyFrom struct {
	mock               *FakeTxMock
	defaultExpectation *FakeTxMockCopyFromExpectation
	expectations       []*FakeTxMockCopyFromExpectation

	callArgs []*FakeTxMockCopyFromParams
	mutex    sync.RWMutex
}

// FakeTxMockCopyFromExpectation specifies expectation struct of the FakeTx.CopyFrom
type FakeTxMockCopyFromExpectation struct {
	mock    *FakeTxMock
	params  *FakeTxMockCopyFromParams
	results *FakeTxMockCopyFromResults
	Counter uint64
}

// FakeTxMockCopyFromParams contains parameters of the FakeTx.CopyFrom
type FakeTxMockCopyFromParams struct {
	ctx         context.Context
	tableName   pgx.Identifier
	columnNames []string
	rowSrc      pgx.CopyFromSource
}

// FakeTxMockCopyFromResults contains results of the FakeTx.CopyFrom
type FakeTxMockCopyFromResults struct {
	i1  int64
	err error
}

// Expect sets up expected params for FakeTx.CopyFrom
func (mmCopyFrom *mFakeTxMockCopyFrom) Expect(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) *mFakeTxMockCopyFrom {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("FakeTxMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &FakeTxMockCopyFromExpectation{}
	}

	mmCopyFrom.defaultExpectation.params = &FakeTxMockCopyFromParams{ctx, tableName, columnNames, rowSrc}
	for _, e := range mmCopyFrom.expectations {
		if minimock.Equal(e.params, mmCopyFrom.defaultExpectation.params) {
			mmCopyFrom.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCopyFrom.defaultExpectation.params)
		}
	}

	return mmCopyFrom
}

// Inspect accepts an inspector function that has same arguments as the FakeTx.CopyFrom
func (mmCopyFrom *mFakeTxMockCopyFrom) Inspect(f func(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource)) *mFakeTxMockCopyFrom {
	if mmCopyFrom.mock.inspectFuncCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("Inspect function is already set for FakeTxMock.CopyFrom")
	}

	mmCopyFrom.mock.inspectFuncCopyFrom = f

	return mmCopyFrom
}

// Return sets up results that will be returned by FakeTx.CopyFrom
func (mmCopyFrom *mFakeTxMockCopyFrom) Return(i1 int64, err error) *FakeTxMock {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("FakeTxMock.CopyFrom mock is already set by Set")
	}

	if mmCopyFrom.defaultExpectation == nil {
		mmCopyFrom.defaultExpectation = &FakeTxMockCopyFromExpectation{mock: mmCopyFrom.mock}
	}
	mmCopyFrom.defaultExpectation.results = &FakeTxMockCopyFromResults{i1, err}
	return mmCopyFrom.mock
}

// Set uses given function f to mock the FakeTx.CopyFrom method
func (mmCopyFrom *mFakeTxMockCopyFrom) Set(f func(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) (i1 int64, err error)) *FakeTxMock {
	if mmCopyFrom.defaultExpectation != nil {
		mmCopyFrom.mock.t.Fatalf("Default expectation is already set for the FakeTx.CopyFrom method")
	}

	if len(mmCopyFrom.expectations) > 0 {
		mmCopyFrom.mock.t.Fatalf("Some expectations are already set for the FakeTx.CopyFrom method")
	}

	mmCopyFrom.mock.funcCopyFrom = f
	return mmCopyFrom.mock
}

// When sets expectation for the FakeTx.CopyFrom which will trigger the result defined by the following
// Then helper
func (mmCopyFrom *mFakeTxMockCopyFrom) When(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) *FakeTxMockCopyFromExpectation {
	if mmCopyFrom.mock.funcCopyFrom != nil {
		mmCopyFrom.mock.t.Fatalf("FakeTxMock.CopyFrom mock is already set by Set")
	}

	expectation := &FakeTxMockCopyFromExpectation{
		mock:   mmCopyFrom.mock,
		params: &FakeTxMockCopyFromParams{ctx, tableName, columnNames, rowSrc},
	}
	mmCopyFrom.expectations = append(mmCopyFrom.expectations, expectation)
	return expectation
}

// Then sets up FakeTx.CopyFrom return parameters for the expectation previously defined by the When method
func (e *FakeTxMockCopyFromExpectation) Then(i1 int64, err error) *FakeTxMock {
	e.results = &FakeTxMockCopyFromResults{i1, err}
	return e.mock
}

// CopyFrom implements service.FakeTx
func (mmCopyFrom *FakeTxMock) CopyFrom(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCopyFrom.beforeCopyFromCounter, 1)
	defer mm_atomic.AddUint64(&mmCopyFrom.afterCopyFromCounter, 1)

	if mmCopyFrom.inspectFuncCopyFrom != nil {
		mmCopyFrom.inspectFuncCopyFrom(ctx, tableName, columnNames, rowSrc)
	}

	mm_params := FakeTxMockCopyFromParams{ctx, tableName, columnNames, rowSrc}

	// Record call args
	mmCopyFrom.CopyFromMock.mutex.Lock()
	mmCopyFrom.CopyFromMock.callArgs = append(mmCopyFrom.CopyFromMock.callArgs, &mm_params)
	mmCopyFrom.CopyFromMock.mutex.Unlock()

	for _, e := range mmCopyFrom.CopyFromMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCopyFrom.CopyFromMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCopyFrom.CopyFromMock.defaultExpectation.Counter, 1)
		mm_want := mmCopyFrom.CopyFromMock.defaultExpectation.params
		mm_got := FakeTxMockCopyFromParams{ctx, tableName, columnNames, rowSrc}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCopyFrom.t.Errorf("FakeTxMock.CopyFrom got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCopyFrom.CopyFromMock.defaultExpectation.results
		if mm_results == nil {
			mmCopyFrom.t.Fatal("No results are set for the FakeTxMock.CopyFrom")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCopyFrom.funcCopyFrom != nil {
		return mmCopyFrom.funcCopyFrom(ctx, tableName, columnNames, rowSrc)
	}
	mmCopyFrom.t.Fatalf("Unexpected call to FakeTxMock.CopyFrom. %v %v %v %v", ctx, tableName, columnNames, rowSrc)
	return
}

// CopyFromAfterCounter returns a count of finished FakeTxMock.CopyFrom invocations
func (mmCopyFrom *FakeTxMock) CopyFromAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyFrom.afterCopyFromCounter)
}

// CopyFromBeforeCounter returns a count of FakeTxMock.CopyFrom invocations
func (mmCopyFrom *FakeTxMock) CopyFromBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCopyFrom.beforeCopyFromCounter)
}

// Calls returns a list of arguments used in each call to FakeTxMock.CopyFrom.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCopyFrom *mFakeTxMockCopyFrom) Calls() []*FakeTxMockCopyFromParams {
	mmCopyFrom.mutex.RLock()

	argCopy := make([]*FakeTxMockCopyFromParams, len(mmCopyFrom.callArgs))
	copy(argCopy, mmCopyFrom.callArgs)

	mmCopyFrom.mutex.RUnlock()

	return argCopy
}

// MinimockCopyFromDone returns true if the count of the CopyFrom invocations corresponds
// the number of defined expectations
func (m *FakeTxMock) MinimockCopyFromDone() bool {
	for _, e := range m.CopyFromMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyFromMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyFromCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyFrom != nil && mm_atomic.LoadUint64(&m.afterCopyFromCounter) < 1 {
		return false
	}
	return true
}

// MinimockCopyFromInspect logs each unmet expectation
func (m *FakeTxMock) MinimockCopyFromInspect() {
	for _, e := range m.CopyFromMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FakeTxMock.CopyFrom with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CopyFromMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCopyFromCounter) < 1 {
		if m.CopyFromMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FakeTxMock.CopyFrom")
		} else {
			m.t.Errorf("Expected call to FakeTxMock.CopyFrom with params: %#v", *m.CopyFromMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCopyFrom != nil && mm_atomic.LoadUint64(&m.afterCopyFromCounter) < 1 {
		m.t.Error("Expected call to FakeTxMock.CopyFrom")
	}
}

type mFakeTxMockExec struct {
	mock               *FakeTxMock
	defaultExpectation *FakeTxMockExecExpectation
	expectations       []*FakeTxMockExecExpectation

	callArgs []*FakeTxMockExecParams
	mutex    sync.RWMutex
}

// FakeTxMockExecExpectation specifies expectation struct of the FakeTx.Exec
type FakeTxMockExecExpectation struct {
	mock    *FakeTxMock
	params  *FakeTxMockExecParams
	results *FakeTxMockExecResults
	Counter uint64
}

// FakeTxMockExecParams contains parameters of the FakeTx.Exec
type FakeTxMockExecParams struct {
	ctx       context.Context
	sql       string
	arguments []interface{}
}

// FakeTxMockExecResults contains results of the FakeTx.Exec
type FakeTxMockExecResults struct {
	commandTag pgconn.CommandTag
	err        error
}

// Expect sets up expected params for FakeTx.Exec
func (mmExec *mFakeTxMockExec) Expect(ctx context.Context, sql string, arguments ...interface{}) *mFakeTxMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("FakeTxMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &FakeTxMockExecExpectation{}
	}

	mmExec.defaultExpectation.params = &FakeTxMockExecParams{ctx, sql, arguments}
	for _, e := range mmExec.expectations {
		if minimock.Equal(e.params, mmExec.defaultExpectation.params) {
			mmExec.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExec.defaultExpectation.params)
		}
	}

	return mmExec
}

// Inspect accepts an inspector function that has same arguments as the FakeTx.Exec
func (mmExec *mFakeTxMockExec) Inspect(f func(ctx context.Context, sql string, arguments ...interface{})) *mFakeTxMockExec {
	if mmExec.mock.inspectFuncExec != nil {
		mmExec.mock.t.Fatalf("Inspect function is already set for FakeTxMock.Exec")
	}

	mmExec.mock.inspectFuncExec = f

	return mmExec
}

// Return sets up results that will be returned by FakeTx.Exec
func (mmExec *mFakeTxMockExec) Return(commandTag pgconn.CommandTag, err error) *FakeTxMock {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("FakeTxMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &FakeTxMockExecExpectation{mock: mmExec.mock}
	}
	mmExec.defaultExpectation.results = &FakeTxMockExecResults{commandTag, err}
	return mmExec.mock
}

// Set uses given function f to mock the FakeTx.Exec method
func (mmExec *mFakeTxMockExec) Set(f func(ctx context.Context, sql string, arguments ...interface{}) (commandTag pgconn.CommandTag, err error)) *FakeTxMock {
	if mmExec.defaultExpectation != nil {
		mmExec.mock.t.Fatalf("Default expectation is already set for the FakeTx.Exec method")
	}

	if len(mmExec.expectations) > 0 {
		mmExec.mock.t.Fatalf("Some expectations are already set for the FakeTx.Exec method")
	}

	mmExec.mock.funcExec = f
	return mmExec.mock
}

// When sets expectation for the FakeTx.Exec which will trigger the result defined by the following
// Then helper
func (mmExec *mFakeTxMockExec) When(ctx context.Context, sql string, arguments ...interface{}) *FakeTxMockExecExpectation {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("FakeTxMock.Exec mock is already set by Set")
	}

	expectation := &FakeTxMockExecExpectation{
		mock:   mmExec.mock,
		params: &FakeTxMockExecParams{ctx, sql, arguments},
	}
	mmExec.expectations = append(mmExec.expectations, expectation)
	return expectation
}

// Then sets up FakeTx.Exec return parameters for the expectation previously defined by the When method
func (e *FakeTxMockExecExpectation) Then(commandTag pgconn.CommandTag, err error) *FakeTxMock {
	e.results = &FakeTxMockExecResults{commandTag, err}
	return e.mock
}

// Exec implements service.FakeTx
func (mmExec *FakeTxMock) Exec(ctx context.Context, sql string, arguments ...interface{}) (commandTag pgconn.CommandTag, err error) {
	mm_atomic.AddUint64(&mmExec.beforeExecCounter, 1)
	defer mm_atomic.AddUint64(&mmExec.afterExecCounter, 1)

	if mmExec.inspectFuncExec != nil {
		mmExec.inspectFuncExec(ctx, sql, arguments...)
	}

	mm_params := FakeTxMockExecParams{ctx, sql, arguments}

	// Record call args
	mmExec.ExecMock.mutex.Lock()
	mmExec.ExecMock.callArgs = append(mmExec.ExecMock.callArgs, &mm_params)
	mmExec.ExecMock.mutex.Unlock()

	for _, e := range mmExec.ExecMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.commandTag, e.results.err
		}
	}

	if mmExec.ExecMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExec.ExecMock.defaultExpectation.Counter, 1)
		mm_want := mmExec.ExecMock.defaultExpectation.params
		mm_got := FakeTxMockExecParams{ctx, sql, arguments}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExec.t.Errorf("FakeTxMock.Exec got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExec.ExecMock.defaultExpectation.results
		if mm_results == nil {
			mmExec.t.Fatal("No results are set for the FakeTxMock.Exec")
		}
		return (*mm_results).commandTag, (*mm_results).err
	}
	if mmExec.funcExec != nil {
		return mmExec.funcExec(ctx, sql, arguments...)
	}
	mmExec.t.Fatalf("Unexpected call to FakeTxMock.Exec. %v %v %v", ctx, sql, arguments)
	return
}

// ExecAfterCounter returns a count of finished FakeTxMock.Exec invocations
func (mmExec *FakeTxMock) ExecAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExec.afterExecCounter)
}

// ExecBeforeCounter returns a count of FakeTxMock.Exec invocations
func (mmExec *FakeTxMock) ExecBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExec.beforeExecCounter)
}

// Calls returns a list of arguments used in each call to FakeTxMock.Exec.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExec *mFakeTxMockExec) Calls() []*FakeTxMockExecParams {
	mmExec.mutex.RLock()

	argCopy := make([]*FakeTxMockExecParams, len(mmExec.callArgs))
	copy(argCopy, mmExec.callArgs)

	mmExec.mutex.RUnlock()

	return argCopy
}

// MinimockExecDone returns true if the count of the Exec invocations corresponds
// the number of defined expectations
func (m *FakeTxMock) MinimockExecDone() bool {
	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExecMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExec != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		return false
	}
	return true
}

// MinimockExecInspect logs each unmet expectation
func (m *FakeTxMock) MinimockExecInspect() {
	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FakeTxMock.Exec with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExecMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		if m.ExecMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FakeTxMock.Exec")
		} else {
			m.t.Errorf("Expected call to FakeTxMock.Exec with params: %#v", *m.ExecMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExec != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		m.t.Error("Expected call to FakeTxMock.Exec")
	}
}

type mFakeTxMockLargeObjects struct {
	mock               *FakeTxMock
	defaultExpectation *FakeTxMockLargeObjectsExpectation
	expectations       []*FakeTxMockLargeObjectsExpectation
}

// FakeTxMockLargeObjectsExpectation specifies expectation struct of the FakeTx.LargeObjects
type FakeTxMockLargeObjectsExpectation struct {
	mock *FakeTxMock

	results *FakeTxMockLargeObjectsResults
	Counter uint64
}

// FakeTxMockLargeObjectsResults contains results of the FakeTx.LargeObjects
type FakeTxMockLargeObjectsResults struct {
	l1 pgx.LargeObjects
}

// Expect sets up expected params for FakeTx.LargeObjects
func (mmLargeObjects *mFakeTxMockLargeObjects) Expect() *mFakeTxMockLargeObjects {
	if mmLargeObjects.mock.funcLargeObjects != nil {
		mmLargeObjects.mock.t.Fatalf("FakeTxMock.LargeObjects mock is already set by Set")
	}

	if mmLargeObjects.defaultExpectation == nil {
		mmLargeObjects.defaultExpectation = &FakeTxMockLargeObjectsExpectation{}
	}

	return mmLargeObjects
}

// Inspect accepts an inspector function that has same arguments as the FakeTx.LargeObjects
func (mmLargeObjects *mFakeTxMockLargeObjects) Inspect(f func()) *mFakeTxMockLargeObjects {
	if mmLargeObjects.mock.inspectFuncLargeObjects != nil {
		mmLargeObjects.mock.t.Fatalf("Inspect function is already set for FakeTxMock.LargeObjects")
	}

	mmLargeObjects.mock.inspectFuncLargeObjects = f

	return mmLargeObjects
}

// Return sets up results that will be returned by FakeTx.LargeObjects
func (mmLargeObjects *mFakeTxMockLargeObjects) Return(l1 pgx.LargeObjects) *FakeTxMock {
	if mmLargeObjects.mock.funcLargeObjects != nil {
		mmLargeObjects.mock.t.Fatalf("FakeTxMock.LargeObjects mock is already set by Set")
	}

	if mmLargeObjects.defaultExpectation == nil {
		mmLargeObjects.defaultExpectation = &FakeTxMockLargeObjectsExpectation{mock: mmLargeObjects.mock}
	}
	mmLargeObjects.defaultExpectation.results = &FakeTxMockLargeObjectsResults{l1}
	return mmLargeObjects.mock
}

// Set uses given function f to mock the FakeTx.LargeObjects method
func (mmLargeObjects *mFakeTxMockLargeObjects) Set(f func() (l1 pgx.LargeObjects)) *FakeTxMock {
	if mmLargeObjects.defaultExpectation != nil {
		mmLargeObjects.mock.t.Fatalf("Default expectation is already set for the FakeTx.LargeObjects method")
	}

	if len(mmLargeObjects.expectations) > 0 {
		mmLargeObjects.mock.t.Fatalf("Some expectations are already set for the FakeTx.LargeObjects method")
	}

	mmLargeObjects.mock.funcLargeObjects = f
	return mmLargeObjects.mock
}

// LargeObjects implements service.FakeTx
func (mmLargeObjects *FakeTxMock) LargeObjects() (l1 pgx.LargeObjects) {
	mm_atomic.AddUint64(&mmLargeObjects.beforeLargeObjectsCounter, 1)
	defer mm_atomic.AddUint64(&mmLargeObjects.afterLargeObjectsCounter, 1)

	if mmLargeObjects.inspectFuncLargeObjects != nil {
		mmLargeObjects.inspectFuncLargeObjects()
	}

	if mmLargeObjects.LargeObjectsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLargeObjects.LargeObjectsMock.defaultExpectation.Counter, 1)

		mm_results := mmLargeObjects.LargeObjectsMock.defaultExpectation.results
		if mm_results == nil {
			mmLargeObjects.t.Fatal("No results are set for the FakeTxMock.LargeObjects")
		}
		return (*mm_results).l1
	}
	if mmLargeObjects.funcLargeObjects != nil {
		return mmLargeObjects.funcLargeObjects()
	}
	mmLargeObjects.t.Fatalf("Unexpected call to FakeTxMock.LargeObjects.")
	return
}

// LargeObjectsAfterCounter returns a count of finished FakeTxMock.LargeObjects invocations
func (mmLargeObjects *FakeTxMock) LargeObjectsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLargeObjects.afterLargeObjectsCounter)
}

// LargeObjectsBeforeCounter returns a count of FakeTxMock.LargeObjects invocations
func (mmLargeObjects *FakeTxMock) LargeObjectsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLargeObjects.beforeLargeObjectsCounter)
}

// MinimockLargeObjectsDone returns true if the count of the LargeObjects invocations corresponds
// the number of defined expectations
func (m *FakeTxMock) MinimockLargeObjectsDone() bool {
	for _, e := range m.LargeObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LargeObjectsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLargeObjectsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLargeObjects != nil && mm_atomic.LoadUint64(&m.afterLargeObjectsCounter) < 1 {
		return false
	}
	return true
}

// MinimockLargeObjectsInspect logs each unmet expectation
func (m *FakeTxMock) MinimockLargeObjectsInspect() {
	for _, e := range m.LargeObjectsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to FakeTxMock.LargeObjects")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.LargeObjectsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterLargeObjectsCounter) < 1 {
		m.t.Error("Expected call to FakeTxMock.LargeObjects")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLargeObjects != nil && mm_atomic.LoadUint64(&m.afterLargeObjectsCounter) < 1 {
		m.t.Error("Expected call to FakeTxMock.LargeObjects")
	}
}

type mFakeTxMockPrepare struct {
	mock               *FakeTxMock
	defaultExpectation *FakeTxMockPrepareExpectation
	expectations       []*FakeTxMockPrepareExpectation

	callArgs []*FakeTxMockPrepareParams
	mutex    sync.RWMutex
}

// FakeTxMockPrepareExpectation specifies expectation struct of the FakeTx.Prepare
type FakeTxMockPrepareExpectation struct {
	mock    *FakeTxMock
	params  *FakeTxMockPrepareParams
	results *FakeTxMockPrepareResults
	Counter uint64
}

// FakeTxMockPrepareParams contains parameters of the FakeTx.Prepare
type FakeTxMockPrepareParams struct {
	ctx  context.Context
	name string
	sql  string
}

// FakeTxMockPrepareResults contains results of the FakeTx.Prepare
type FakeTxMockPrepareResults struct {
	sp1 *pgconn.StatementDescription
	err error
}

// Expect sets up expected params for FakeTx.Prepare
func (mmPrepare *mFakeTxMockPrepare) Expect(ctx context.Context, name string, sql string) *mFakeTxMockPrepare {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("FakeTxMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &FakeTxMockPrepareExpectation{}
	}

	mmPrepare.defaultExpectation.params = &FakeTxMockPrepareParams{ctx, name, sql}
	for _, e := range mmPrepare.expectations {
		if minimock.Equal(e.params, mmPrepare.defaultExpectation.params) {
			mmPrepare.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPrepare.defaultExpectation.params)
		}
	}

	return mmPrepare
}

// Inspect accepts an inspector function that has same arguments as the FakeTx.Prepare
func (mmPrepare *mFakeTxMockPrepare) Inspect(f func(ctx context.Context, name string, sql string)) *mFakeTxMockPrepare {
	if mmPrepare.mock.inspectFuncPrepare != nil {
		mmPrepare.mock.t.Fatalf("Inspect function is already set for FakeTxMock.Prepare")
	}

	mmPrepare.mock.inspectFuncPrepare = f

	return mmPrepare
}

// Return sets up results that will be returned by FakeTx.Prepare
func (mmPrepare *mFakeTxMockPrepare) Return(sp1 *pgconn.StatementDescription, err error) *FakeTxMock {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("FakeTxMock.Prepare mock is already set by Set")
	}

	if mmPrepare.defaultExpectation == nil {
		mmPrepare.defaultExpectation = &FakeTxMockPrepareExpectation{mock: mmPrepare.mock}
	}
	mmPrepare.defaultExpectation.results = &FakeTxMockPrepareResults{sp1, err}
	return mmPrepare.mock
}

// Set uses given function f to mock the FakeTx.Prepare method
func (mmPrepare *mFakeTxMockPrepare) Set(f func(ctx context.Context, name string, sql string) (sp1 *pgconn.StatementDescription, err error)) *FakeTxMock {
	if mmPrepare.defaultExpectation != nil {
		mmPrepare.mock.t.Fatalf("Default expectation is already set for the FakeTx.Prepare method")
	}

	if len(mmPrepare.expectations) > 0 {
		mmPrepare.mock.t.Fatalf("Some expectations are already set for the FakeTx.Prepare method")
	}

	mmPrepare.mock.funcPrepare = f
	return mmPrepare.mock
}

// When sets expectation for the FakeTx.Prepare which will trigger the result defined by the following
// Then helper
func (mmPrepare *mFakeTxMockPrepare) When(ctx context.Context, name string, sql string) *FakeTxMockPrepareExpectation {
	if mmPrepare.mock.funcPrepare != nil {
		mmPrepare.mock.t.Fatalf("FakeTxMock.Prepare mock is already set by Set")
	}

	expectation := &FakeTxMockPrepareExpectation{
		mock:   mmPrepare.mock,
		params: &FakeTxMockPrepareParams{ctx, name, sql},
	}
	mmPrepare.expectations = append(mmPrepare.expectations, expectation)
	return expectation
}

// Then sets up FakeTx.Prepare return parameters for the expectation previously defined by the When method
func (e *FakeTxMockPrepareExpectation) Then(sp1 *pgconn.StatementDescription, err error) *FakeTxMock {
	e.results = &FakeTxMockPrepareResults{sp1, err}
	return e.mock
}

// Prepare implements service.FakeTx
func (mmPrepare *FakeTxMock) Prepare(ctx context.Context, name string, sql string) (sp1 *pgconn.StatementDescription, err error) {
	mm_atomic.AddUint64(&mmPrepare.beforePrepareCounter, 1)
	defer mm_atomic.AddUint64(&mmPrepare.afterPrepareCounter, 1)

	if mmPrepare.inspectFuncPrepare != nil {
		mmPrepare.inspectFuncPrepare(ctx, name, sql)
	}

	mm_params := FakeTxMockPrepareParams{ctx, name, sql}

	// Record call args
	mmPrepare.PrepareMock.mutex.Lock()
	mmPrepare.PrepareMock.callArgs = append(mmPrepare.PrepareMock.callArgs, &mm_params)
	mmPrepare.PrepareMock.mutex.Unlock()

	for _, e := range mmPrepare.PrepareMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmPrepare.PrepareMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPrepare.PrepareMock.defaultExpectation.Counter, 1)
		mm_want := mmPrepare.PrepareMock.defaultExpectation.params
		mm_got := FakeTxMockPrepareParams{ctx, name, sql}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPrepare.t.Errorf("FakeTxMock.Prepare got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPrepare.PrepareMock.defaultExpectation.results
		if mm_results == nil {
			mmPrepare.t.Fatal("No results are set for the FakeTxMock.Prepare")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmPrepare.funcPrepare != nil {
		return mmPrepare.funcPrepare(ctx, name, sql)
	}
	mmPrepare.t.Fatalf("Unexpected call to FakeTxMock.Prepare. %v %v %v", ctx, name, sql)
	return
}

// PrepareAfterCounter returns a count of finished FakeTxMock.Prepare invocations
func (mmPrepare *FakeTxMock) PrepareAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrepare.afterPrepareCounter)
}

// PrepareBeforeCounter returns a count of FakeTxMock.Prepare invocations
func (mmPrepare *FakeTxMock) PrepareBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPrepare.beforePrepareCounter)
}

// Calls returns a list of arguments used in each call to FakeTxMock.Prepare.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPrepare *mFakeTxMockPrepare) Calls() []*FakeTxMockPrepareParams {
	mmPrepare.mutex.RLock()

	argCopy := make([]*FakeTxMockPrepareParams, len(mmPrepare.callArgs))
	copy(argCopy, mmPrepare.callArgs)

	mmPrepare.mutex.RUnlock()

	return argCopy
}

// MinimockPrepareDone returns true if the count of the Prepare invocations corresponds
// the number of defined expectations
func (m *FakeTxMock) MinimockPrepareDone() bool {
	for _, e := range m.PrepareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrepareMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrepareCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrepare != nil && mm_atomic.LoadUint64(&m.afterPrepareCounter) < 1 {
		return false
	}
	return true
}

// MinimockPrepareInspect logs each unmet expectation
func (m *FakeTxMock) MinimockPrepareInspect() {
	for _, e := range m.PrepareMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FakeTxMock.Prepare with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PrepareMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPrepareCounter) < 1 {
		if m.PrepareMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FakeTxMock.Prepare")
		} else {
			m.t.Errorf("Expected call to FakeTxMock.Prepare with params: %#v", *m.PrepareMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPrepare != nil && mm_atomic.LoadUint64(&m.afterPrepareCounter) < 1 {
		m.t.Error("Expected call to FakeTxMock.Prepare")
	}
}

type mFakeTxMockQuery struct {
	mock               *FakeTxMock
	defaultExpectation *FakeTxMockQueryExpectation
	expectations       []*FakeTxMockQueryExpectation

	callArgs []*FakeTxMockQueryParams
	mutex    sync.RWMutex
}

// FakeTxMockQueryExpectation specifies expectation struct of the FakeTx.Query
type FakeTxMockQueryExpectation struct {
	mock    *FakeTxMock
	params  *FakeTxMockQueryParams
	results *FakeTxMockQueryResults
	Counter uint64
}

// FakeTxMockQueryParams contains parameters of the FakeTx.Query
type FakeTxMockQueryParams struct {
	ctx  context.Context
	sql  string
	args []interface{}
}

// FakeTxMockQueryResults contains results of the FakeTx.Query
type FakeTxMockQueryResults struct {
	r1  pgx.Rows
	err error
}

// Expect sets up expected params for FakeTx.Query
func (mmQuery *mFakeTxMockQuery) Expect(ctx context.Context, sql string, args ...interface{}) *mFakeTxMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("FakeTxMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &FakeTxMockQueryExpectation{}
	}

	mmQuery.defaultExpectation.params = &FakeTxMockQueryParams{ctx, sql, args}
	for _, e := range mmQuery.expectations {
		if minimock.Equal(e.params, mmQuery.defaultExpectation.params) {
			mmQuery.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQuery.defaultExpectation.params)
		}
	}

	return mmQuery
}

// Inspect accepts an inspector function that has same arguments as the FakeTx.Query
func (mmQuery *mFakeTxMockQuery) Inspect(f func(ctx context.Context, sql string, args ...interface{})) *mFakeTxMockQuery {
	if mmQuery.mock.inspectFuncQuery != nil {
		mmQuery.mock.t.Fatalf("Inspect function is already set for FakeTxMock.Query")
	}

	mmQuery.mock.inspectFuncQuery = f

	return mmQuery
}

// Return sets up results that will be returned by FakeTx.Query
func (mmQuery *mFakeTxMockQuery) Return(r1 pgx.Rows, err error) *FakeTxMock {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("FakeTxMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &FakeTxMockQueryExpectation{mock: mmQuery.mock}
	}
	mmQuery.defaultExpectation.results = &FakeTxMockQueryResults{r1, err}
	return mmQuery.mock
}

// Set uses given function f to mock the FakeTx.Query method
func (mmQuery *mFakeTxMockQuery) Set(f func(ctx context.Context, sql string, args ...interface{}) (r1 pgx.Rows, err error)) *FakeTxMock {
	if mmQuery.defaultExpectation != nil {
		mmQuery.mock.t.Fatalf("Default expectation is already set for the FakeTx.Query method")
	}

	if len(mmQuery.expectations) > 0 {
		mmQuery.mock.t.Fatalf("Some expectations are already set for the FakeTx.Query method")
	}

	mmQuery.mock.funcQuery = f
	return mmQuery.mock
}

// When sets expectation for the FakeTx.Query which will trigger the result defined by the following
// Then helper
func (mmQuery *mFakeTxMockQuery) When(ctx context.Context, sql string, args ...interface{}) *FakeTxMockQueryExpectation {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("FakeTxMock.Query mock is already set by Set")
	}

	expectation := &FakeTxMockQueryExpectation{
		mock:   mmQuery.mock,
		params: &FakeTxMockQueryParams{ctx, sql, args},
	}
	mmQuery.expectations = append(mmQuery.expectations, expectation)
	return expectation
}

// Then sets up FakeTx.Query return parameters for the expectation previously defined by the When method
func (e *FakeTxMockQueryExpectation) Then(r1 pgx.Rows, err error) *FakeTxMock {
	e.results = &FakeTxMockQueryResults{r1, err}
	return e.mock
}

// Query implements service.FakeTx
func (mmQuery *FakeTxMock) Query(ctx context.Context, sql string, args ...interface{}) (r1 pgx.Rows, err error) {
	mm_atomic.AddUint64(&mmQuery.beforeQueryCounter, 1)
	defer mm_atomic.AddUint64(&mmQuery.afterQueryCounter, 1)

	if mmQuery.inspectFuncQuery != nil {
		mmQuery.inspectFuncQuery(ctx, sql, args...)
	}

	mm_params := FakeTxMockQueryParams{ctx, sql, args}

	// Record call args
	mmQuery.QueryMock.mutex.Lock()
	mmQuery.QueryMock.callArgs = append(mmQuery.QueryMock.callArgs, &mm_params)
	mmQuery.QueryMock.mutex.Unlock()

	for _, e := range mmQuery.QueryMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmQuery.QueryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQuery.QueryMock.defaultExpectation.Counter, 1)
		mm_want := mmQuery.QueryMock.defaultExpectation.params
		mm_got := FakeTxMockQueryParams{ctx, sql, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQuery.t.Errorf("FakeTxMock.Query got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQuery.QueryMock.defaultExpectation.results
		if mm_results == nil {
			mmQuery.t.Fatal("No results are set for the FakeTxMock.Query")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmQuery.funcQuery != nil {
		return mmQuery.funcQuery(ctx, sql, args...)
	}
	mmQuery.t.Fatalf("Unexpected call to FakeTxMock.Query. %v %v %v", ctx, sql, args)
	return
}

// QueryAfterCounter returns a count of finished FakeTxMock.Query invocations
func (mmQuery *FakeTxMock) QueryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuery.afterQueryCounter)
}

// QueryBeforeCounter returns a count of FakeTxMock.Query invocations
func (mmQuery *FakeTxMock) QueryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuery.beforeQueryCounter)
}

// Calls returns a list of arguments used in each call to FakeTxMock.Query.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQuery *mFakeTxMockQuery) Calls() []*FakeTxMockQueryParams {
	mmQuery.mutex.RLock()

	argCopy := make([]*FakeTxMockQueryParams, len(mmQuery.callArgs))
	copy(argCopy, mmQuery.callArgs)

	mmQuery.mutex.RUnlock()

	return argCopy
}

// MinimockQueryDone returns true if the count of the Query invocations corresponds
// the number of defined expectations
func (m *FakeTxMock) MinimockQueryDone() bool {
	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuery != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		return false
	}
	return true
}

// MinimockQueryInspect logs each unmet expectation
func (m *FakeTxMock) MinimockQueryInspect() {
	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FakeTxMock.Query with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		if m.QueryMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FakeTxMock.Query")
		} else {
			m.t.Errorf("Expected call to FakeTxMock.Query with params: %#v", *m.QueryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuery != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		m.t.Error("Expected call to FakeTxMock.Query")
	}
}

type mFakeTxMockQueryFunc struct {
	mock               *FakeTxMock
	defaultExpectation *FakeTxMockQueryFuncExpectation
	expectations       []*FakeTxMockQueryFuncExpectation

	callArgs []*FakeTxMockQueryFuncParams
	mutex    sync.RWMutex
}

// FakeTxMockQueryFuncExpectation specifies expectation struct of the FakeTx.QueryFunc
type FakeTxMockQueryFuncExpectation struct {
	mock    *FakeTxMock
	params  *FakeTxMockQueryFuncParams
	results *FakeTxMockQueryFuncResults
	Counter uint64
}

// FakeTxMockQueryFuncParams contains parameters of the FakeTx.QueryFunc
type FakeTxMockQueryFuncParams struct {
	ctx   context.Context
	sql   string
	args  []interface{}
	scans []interface{}
	f     func(pgx.QueryFuncRow) error
}

// FakeTxMockQueryFuncResults contains results of the FakeTx.QueryFunc
type FakeTxMockQueryFuncResults struct {
	c2  pgconn.CommandTag
	err error
}

// Expect sets up expected params for FakeTx.QueryFunc
func (mmQueryFunc *mFakeTxMockQueryFunc) Expect(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(pgx.QueryFuncRow) error) *mFakeTxMockQueryFunc {
	if mmQueryFunc.mock.funcQueryFunc != nil {
		mmQueryFunc.mock.t.Fatalf("FakeTxMock.QueryFunc mock is already set by Set")
	}

	if mmQueryFunc.defaultExpectation == nil {
		mmQueryFunc.defaultExpectation = &FakeTxMockQueryFuncExpectation{}
	}

	mmQueryFunc.defaultExpectation.params = &FakeTxMockQueryFuncParams{ctx, sql, args, scans, f}
	for _, e := range mmQueryFunc.expectations {
		if minimock.Equal(e.params, mmQueryFunc.defaultExpectation.params) {
			mmQueryFunc.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQueryFunc.defaultExpectation.params)
		}
	}

	return mmQueryFunc
}

// Inspect accepts an inspector function that has same arguments as the FakeTx.QueryFunc
func (mmQueryFunc *mFakeTxMockQueryFunc) Inspect(f func(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(pgx.QueryFuncRow) error)) *mFakeTxMockQueryFunc {
	if mmQueryFunc.mock.inspectFuncQueryFunc != nil {
		mmQueryFunc.mock.t.Fatalf("Inspect function is already set for FakeTxMock.QueryFunc")
	}

	mmQueryFunc.mock.inspectFuncQueryFunc = f

	return mmQueryFunc
}

// Return sets up results that will be returned by FakeTx.QueryFunc
func (mmQueryFunc *mFakeTxMockQueryFunc) Return(c2 pgconn.CommandTag, err error) *FakeTxMock {
	if mmQueryFunc.mock.funcQueryFunc != nil {
		mmQueryFunc.mock.t.Fatalf("FakeTxMock.QueryFunc mock is already set by Set")
	}

	if mmQueryFunc.defaultExpectation == nil {
		mmQueryFunc.defaultExpectation = &FakeTxMockQueryFuncExpectation{mock: mmQueryFunc.mock}
	}
	mmQueryFunc.defaultExpectation.results = &FakeTxMockQueryFuncResults{c2, err}
	return mmQueryFunc.mock
}

// Set uses given function f to mock the FakeTx.QueryFunc method
func (mmQueryFunc *mFakeTxMockQueryFunc) Set(f func(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(pgx.QueryFuncRow) error) (c2 pgconn.CommandTag, err error)) *FakeTxMock {
	if mmQueryFunc.defaultExpectation != nil {
		mmQueryFunc.mock.t.Fatalf("Default expectation is already set for the FakeTx.QueryFunc method")
	}

	if len(mmQueryFunc.expectations) > 0 {
		mmQueryFunc.mock.t.Fatalf("Some expectations are already set for the FakeTx.QueryFunc method")
	}

	mmQueryFunc.mock.funcQueryFunc = f
	return mmQueryFunc.mock
}

// When sets expectation for the FakeTx.QueryFunc which will trigger the result defined by the following
// Then helper
func (mmQueryFunc *mFakeTxMockQueryFunc) When(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(pgx.QueryFuncRow) error) *FakeTxMockQueryFuncExpectation {
	if mmQueryFunc.mock.funcQueryFunc != nil {
		mmQueryFunc.mock.t.Fatalf("FakeTxMock.QueryFunc mock is already set by Set")
	}

	expectation := &FakeTxMockQueryFuncExpectation{
		mock:   mmQueryFunc.mock,
		params: &FakeTxMockQueryFuncParams{ctx, sql, args, scans, f},
	}
	mmQueryFunc.expectations = append(mmQueryFunc.expectations, expectation)
	return expectation
}

// Then sets up FakeTx.QueryFunc return parameters for the expectation previously defined by the When method
func (e *FakeTxMockQueryFuncExpectation) Then(c2 pgconn.CommandTag, err error) *FakeTxMock {
	e.results = &FakeTxMockQueryFuncResults{c2, err}
	return e.mock
}

// QueryFunc implements service.FakeTx
func (mmQueryFunc *FakeTxMock) QueryFunc(ctx context.Context, sql string, args []interface{}, scans []interface{}, f func(pgx.QueryFuncRow) error) (c2 pgconn.CommandTag, err error) {
	mm_atomic.AddUint64(&mmQueryFunc.beforeQueryFuncCounter, 1)
	defer mm_atomic.AddUint64(&mmQueryFunc.afterQueryFuncCounter, 1)

	if mmQueryFunc.inspectFuncQueryFunc != nil {
		mmQueryFunc.inspectFuncQueryFunc(ctx, sql, args, scans, f)
	}

	mm_params := FakeTxMockQueryFuncParams{ctx, sql, args, scans, f}

	// Record call args
	mmQueryFunc.QueryFuncMock.mutex.Lock()
	mmQueryFunc.QueryFuncMock.callArgs = append(mmQueryFunc.QueryFuncMock.callArgs, &mm_params)
	mmQueryFunc.QueryFuncMock.mutex.Unlock()

	for _, e := range mmQueryFunc.QueryFuncMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmQueryFunc.QueryFuncMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQueryFunc.QueryFuncMock.defaultExpectation.Counter, 1)
		mm_want := mmQueryFunc.QueryFuncMock.defaultExpectation.params
		mm_got := FakeTxMockQueryFuncParams{ctx, sql, args, scans, f}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQueryFunc.t.Errorf("FakeTxMock.QueryFunc got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQueryFunc.QueryFuncMock.defaultExpectation.results
		if mm_results == nil {
			mmQueryFunc.t.Fatal("No results are set for the FakeTxMock.QueryFunc")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmQueryFunc.funcQueryFunc != nil {
		return mmQueryFunc.funcQueryFunc(ctx, sql, args, scans, f)
	}
	mmQueryFunc.t.Fatalf("Unexpected call to FakeTxMock.QueryFunc. %v %v %v %v %v", ctx, sql, args, scans, f)
	return
}

// QueryFuncAfterCounter returns a count of finished FakeTxMock.QueryFunc invocations
func (mmQueryFunc *FakeTxMock) QueryFuncAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryFunc.afterQueryFuncCounter)
}

// QueryFuncBeforeCounter returns a count of FakeTxMock.QueryFunc invocations
func (mmQueryFunc *FakeTxMock) QueryFuncBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryFunc.beforeQueryFuncCounter)
}

// Calls returns a list of arguments used in each call to FakeTxMock.QueryFunc.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQueryFunc *mFakeTxMockQueryFunc) Calls() []*FakeTxMockQueryFuncParams {
	mmQueryFunc.mutex.RLock()

	argCopy := make([]*FakeTxMockQueryFuncParams, len(mmQueryFunc.callArgs))
	copy(argCopy, mmQueryFunc.callArgs)

	mmQueryFunc.mutex.RUnlock()

	return argCopy
}

// MinimockQueryFuncDone returns true if the count of the QueryFunc invocations corresponds
// the number of defined expectations
func (m *FakeTxMock) MinimockQueryFuncDone() bool {
	for _, e := range m.QueryFuncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryFuncMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryFuncCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryFunc != nil && mm_atomic.LoadUint64(&m.afterQueryFuncCounter) < 1 {
		return false
	}
	return true
}

// MinimockQueryFuncInspect logs each unmet expectation
func (m *FakeTxMock) MinimockQueryFuncInspect() {
	for _, e := range m.QueryFuncMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FakeTxMock.QueryFunc with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryFuncMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryFuncCounter) < 1 {
		if m.QueryFuncMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FakeTxMock.QueryFunc")
		} else {
			m.t.Errorf("Expected call to FakeTxMock.QueryFunc with params: %#v", *m.QueryFuncMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryFunc != nil && mm_atomic.LoadUint64(&m.afterQueryFuncCounter) < 1 {
		m.t.Error("Expected call to FakeTxMock.QueryFunc")
	}
}

type mFakeTxMockQueryRow struct {
	mock               *FakeTxMock
	defaultExpectation *FakeTxMockQueryRowExpectation
	expectations       []*FakeTxMockQueryRowExpectation

	callArgs []*FakeTxMockQueryRowParams
	mutex    sync.RWMutex
}

// FakeTxMockQueryRowExpectation specifies expectation struct of the FakeTx.QueryRow
type FakeTxMockQueryRowExpectation struct {
	mock    *FakeTxMock
	params  *FakeTxMockQueryRowParams
	results *FakeTxMockQueryRowResults
	Counter uint64
}

// FakeTxMockQueryRowParams contains parameters of the FakeTx.QueryRow
type FakeTxMockQueryRowParams struct {
	ctx  context.Context
	sql  string
	args []interface{}
}

// FakeTxMockQueryRowResults contains results of the FakeTx.QueryRow
type FakeTxMockQueryRowResults struct {
	r1 pgx.Row
}

// Expect sets up expected params for FakeTx.QueryRow
func (mmQueryRow *mFakeTxMockQueryRow) Expect(ctx context.Context, sql string, args ...interface{}) *mFakeTxMockQueryRow {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("FakeTxMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &FakeTxMockQueryRowExpectation{}
	}

	mmQueryRow.defaultExpectation.params = &FakeTxMockQueryRowParams{ctx, sql, args}
	for _, e := range mmQueryRow.expectations {
		if minimock.Equal(e.params, mmQueryRow.defaultExpectation.params) {
			mmQueryRow.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQueryRow.defaultExpectation.params)
		}
	}

	return mmQueryRow
}

// Inspect accepts an inspector function that has same arguments as the FakeTx.QueryRow
func (mmQueryRow *mFakeTxMockQueryRow) Inspect(f func(ctx context.Context, sql string, args ...interface{})) *mFakeTxMockQueryRow {
	if mmQueryRow.mock.inspectFuncQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("Inspect function is already set for FakeTxMock.QueryRow")
	}

	mmQueryRow.mock.inspectFuncQueryRow = f

	return mmQueryRow
}

// Return sets up results that will be returned by FakeTx.QueryRow
func (mmQueryRow *mFakeTxMockQueryRow) Return(r1 pgx.Row) *FakeTxMock {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("FakeTxMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &FakeTxMockQueryRowExpectation{mock: mmQueryRow.mock}
	}
	mmQueryRow.defaultExpectation.results = &FakeTxMockQueryRowResults{r1}
	return mmQueryRow.mock
}

// Set uses given function f to mock the FakeTx.QueryRow method
func (mmQueryRow *mFakeTxMockQueryRow) Set(f func(ctx context.Context, sql string, args ...interface{}) (r1 pgx.Row)) *FakeTxMock {
	if mmQueryRow.defaultExpectation != nil {
		mmQueryRow.mock.t.Fatalf("Default expectation is already set for the FakeTx.QueryRow method")
	}

	if len(mmQueryRow.expectations) > 0 {
		mmQueryRow.mock.t.Fatalf("Some expectations are already set for the FakeTx.QueryRow method")
	}

	mmQueryRow.mock.funcQueryRow = f
	return mmQueryRow.mock
}

// When sets expectation for the FakeTx.QueryRow which will trigger the result defined by the following
// Then helper
func (mmQueryRow *mFakeTxMockQueryRow) When(ctx context.Context, sql string, args ...interface{}) *FakeTxMockQueryRowExpectation {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("FakeTxMock.QueryRow mock is already set by Set")
	}

	expectation := &FakeTxMockQueryRowExpectation{
		mock:   mmQueryRow.mock,
		params: &FakeTxMockQueryRowParams{ctx, sql, args},
	}
	mmQueryRow.expectations = append(mmQueryRow.expectations, expectation)
	return expectation
}

// Then sets up FakeTx.QueryRow return parameters for the expectation previously defined by the When method
func (e *FakeTxMockQueryRowExpectation) Then(r1 pgx.Row) *FakeTxMock {
	e.results = &FakeTxMockQueryRowResults{r1}
	return e.mock
}

// QueryRow implements service.FakeTx
func (mmQueryRow *FakeTxMock) QueryRow(ctx context.Context, sql string, args ...interface{}) (r1 pgx.Row) {
	mm_atomic.AddUint64(&mmQueryRow.beforeQueryRowCounter, 1)
	defer mm_atomic.AddUint64(&mmQueryRow.afterQueryRowCounter, 1)

	if mmQueryRow.inspectFuncQueryRow != nil {
		mmQueryRow.inspectFuncQueryRow(ctx, sql, args...)
	}

	mm_params := FakeTxMockQueryRowParams{ctx, sql, args}

	// Record call args
	mmQueryRow.QueryRowMock.mutex.Lock()
	mmQueryRow.QueryRowMock.callArgs = append(mmQueryRow.QueryRowMock.callArgs, &mm_params)
	mmQueryRow.QueryRowMock.mutex.Unlock()

	for _, e := range mmQueryRow.QueryRowMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1
		}
	}

	if mmQueryRow.QueryRowMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQueryRow.QueryRowMock.defaultExpectation.Counter, 1)
		mm_want := mmQueryRow.QueryRowMock.defaultExpectation.params
		mm_got := FakeTxMockQueryRowParams{ctx, sql, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQueryRow.t.Errorf("FakeTxMock.QueryRow got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQueryRow.QueryRowMock.defaultExpectation.results
		if mm_results == nil {
			mmQueryRow.t.Fatal("No results are set for the FakeTxMock.QueryRow")
		}
		return (*mm_results).r1
	}
	if mmQueryRow.funcQueryRow != nil {
		return mmQueryRow.funcQueryRow(ctx, sql, args...)
	}
	mmQueryRow.t.Fatalf("Unexpected call to FakeTxMock.QueryRow. %v %v %v", ctx, sql, args)
	return
}

// QueryRowAfterCounter returns a count of finished FakeTxMock.QueryRow invocations
func (mmQueryRow *FakeTxMock) QueryRowAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRow.afterQueryRowCounter)
}

// QueryRowBeforeCounter returns a count of FakeTxMock.QueryRow invocations
func (mmQueryRow *FakeTxMock) QueryRowBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRow.beforeQueryRowCounter)
}

// Calls returns a list of arguments used in each call to FakeTxMock.QueryRow.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQueryRow *mFakeTxMockQueryRow) Calls() []*FakeTxMockQueryRowParams {
	mmQueryRow.mutex.RLock()

	argCopy := make([]*FakeTxMockQueryRowParams, len(mmQueryRow.callArgs))
	copy(argCopy, mmQueryRow.callArgs)

	mmQueryRow.mutex.RUnlock()

	return argCopy
}

// MinimockQueryRowDone returns true if the count of the QueryRow invocations corresponds
// the number of defined expectations
func (m *FakeTxMock) MinimockQueryRowDone() bool {
	for _, e := range m.QueryRowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryRowMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryRowCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryRow != nil && mm_atomic.LoadUint64(&m.afterQueryRowCounter) < 1 {
		return false
	}
	return true
}

// MinimockQueryRowInspect logs each unmet expectation
func (m *FakeTxMock) MinimockQueryRowInspect() {
	for _, e := range m.QueryRowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FakeTxMock.QueryRow with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryRowMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryRowCounter) < 1 {
		if m.QueryRowMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FakeTxMock.QueryRow")
		} else {
			m.t.Errorf("Expected call to FakeTxMock.QueryRow with params: %#v", *m.QueryRowMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryRow != nil && mm_atomic.LoadUint64(&m.afterQueryRowCounter) < 1 {
		m.t.Error("Expected call to FakeTxMock.QueryRow")
	}
}

type mFakeTxMockRollback struct {
	mock               *FakeTxMock
	defaultExpectation *FakeTxMockRollbackExpectation
	expectations       []*FakeTxMockRollbackExpectation

	callArgs []*FakeTxMockRollbackParams
	mutex    sync.RWMutex
}

// FakeTxMockRollbackExpectation specifies expectation struct of the FakeTx.Rollback
type FakeTxMockRollbackExpectation struct {
	mock    *FakeTxMock
	params  *FakeTxMockRollbackParams
	results *FakeTxMockRollbackResults
	Counter uint64
}

// FakeTxMockRollbackParams contains parameters of the FakeTx.Rollback
type FakeTxMockRollbackParams struct {
	ctx context.Context
}

// FakeTxMockRollbackResults contains results of the FakeTx.Rollback
type FakeTxMockRollbackResults struct {
	err error
}

// Expect sets up expected params for FakeTx.Rollback
func (mmRollback *mFakeTxMockRollback) Expect(ctx context.Context) *mFakeTxMockRollback {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("FakeTxMock.Rollback mock is already set by Set")
	}

	if mmRollback.defaultExpectation == nil {
		mmRollback.defaultExpectation = &FakeTxMockRollbackExpectation{}
	}

	mmRollback.defaultExpectation.params = &FakeTxMockRollbackParams{ctx}
	for _, e := range mmRollback.expectations {
		if minimock.Equal(e.params, mmRollback.defaultExpectation.params) {
			mmRollback.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRollback.defaultExpectation.params)
		}
	}

	return mmRollback
}

// Inspect accepts an inspector function that has same arguments as the FakeTx.Rollback
func (mmRollback *mFakeTxMockRollback) Inspect(f func(ctx context.Context)) *mFakeTxMockRollback {
	if mmRollback.mock.inspectFuncRollback != nil {
		mmRollback.mock.t.Fatalf("Inspect function is already set for FakeTxMock.Rollback")
	}

	mmRollback.mock.inspectFuncRollback = f

	return mmRollback
}

// Return sets up results that will be returned by FakeTx.Rollback
func (mmRollback *mFakeTxMockRollback) Return(err error) *FakeTxMock {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("FakeTxMock.Rollback mock is already set by Set")
	}

	if mmRollback.defaultExpectation == nil {
		mmRollback.defaultExpectation = &FakeTxMockRollbackExpectation{mock: mmRollback.mock}
	}
	mmRollback.defaultExpectation.results = &FakeTxMockRollbackResults{err}
	return mmRollback.mock
}

// Set uses given function f to mock the FakeTx.Rollback method
func (mmRollback *mFakeTxMockRollback) Set(f func(ctx context.Context) (err error)) *FakeTxMock {
	if mmRollback.defaultExpectation != nil {
		mmRollback.mock.t.Fatalf("Default expectation is already set for the FakeTx.Rollback method")
	}

	if len(mmRollback.expectations) > 0 {
		mmRollback.mock.t.Fatalf("Some expectations are already set for the FakeTx.Rollback method")
	}

	mmRollback.mock.funcRollback = f
	return mmRollback.mock
}

// When sets expectation for the FakeTx.Rollback which will trigger the result defined by the following
// Then helper
func (mmRollback *mFakeTxMockRollback) When(ctx context.Context) *FakeTxMockRollbackExpectation {
	if mmRollback.mock.funcRollback != nil {
		mmRollback.mock.t.Fatalf("FakeTxMock.Rollback mock is already set by Set")
	}

	expectation := &FakeTxMockRollbackExpectation{
		mock:   mmRollback.mock,
		params: &FakeTxMockRollbackParams{ctx},
	}
	mmRollback.expectations = append(mmRollback.expectations, expectation)
	return expectation
}

// Then sets up FakeTx.Rollback return parameters for the expectation previously defined by the When method
func (e *FakeTxMockRollbackExpectation) Then(err error) *FakeTxMock {
	e.results = &FakeTxMockRollbackResults{err}
	return e.mock
}

// Rollback implements service.FakeTx
func (mmRollback *FakeTxMock) Rollback(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmRollback.beforeRollbackCounter, 1)
	defer mm_atomic.AddUint64(&mmRollback.afterRollbackCounter, 1)

	if mmRollback.inspectFuncRollback != nil {
		mmRollback.inspectFuncRollback(ctx)
	}

	mm_params := FakeTxMockRollbackParams{ctx}

	// Record call args
	mmRollback.RollbackMock.mutex.Lock()
	mmRollback.RollbackMock.callArgs = append(mmRollback.RollbackMock.callArgs, &mm_params)
	mmRollback.RollbackMock.mutex.Unlock()

	for _, e := range mmRollback.RollbackMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRollback.RollbackMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRollback.RollbackMock.defaultExpectation.Counter, 1)
		mm_want := mmRollback.RollbackMock.defaultExpectation.params
		mm_got := FakeTxMockRollbackParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRollback.t.Errorf("FakeTxMock.Rollback got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRollback.RollbackMock.defaultExpectation.results
		if mm_results == nil {
			mmRollback.t.Fatal("No results are set for the FakeTxMock.Rollback")
		}
		return (*mm_results).err
	}
	if mmRollback.funcRollback != nil {
		return mmRollback.funcRollback(ctx)
	}
	mmRollback.t.Fatalf("Unexpected call to FakeTxMock.Rollback. %v", ctx)
	return
}

// RollbackAfterCounter returns a count of finished FakeTxMock.Rollback invocations
func (mmRollback *FakeTxMock) RollbackAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRollback.afterRollbackCounter)
}

// RollbackBeforeCounter returns a count of FakeTxMock.Rollback invocations
func (mmRollback *FakeTxMock) RollbackBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRollback.beforeRollbackCounter)
}

// Calls returns a list of arguments used in each call to FakeTxMock.Rollback.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRollback *mFakeTxMockRollback) Calls() []*FakeTxMockRollbackParams {
	mmRollback.mutex.RLock()

	argCopy := make([]*FakeTxMockRollbackParams, len(mmRollback.callArgs))
	copy(argCopy, mmRollback.callArgs)

	mmRollback.mutex.RUnlock()

	return argCopy
}

// MinimockRollbackDone returns true if the count of the Rollback invocations corresponds
// the number of defined expectations
func (m *FakeTxMock) MinimockRollbackDone() bool {
	for _, e := range m.RollbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RollbackMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRollbackCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRollback != nil && mm_atomic.LoadUint64(&m.afterRollbackCounter) < 1 {
		return false
	}
	return true
}

// MinimockRollbackInspect logs each unmet expectation
func (m *FakeTxMock) MinimockRollbackInspect() {
	for _, e := range m.RollbackMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FakeTxMock.Rollback with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RollbackMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRollbackCounter) < 1 {
		if m.RollbackMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FakeTxMock.Rollback")
		} else {
			m.t.Errorf("Expected call to FakeTxMock.Rollback with params: %#v", *m.RollbackMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRollback != nil && mm_atomic.LoadUint64(&m.afterRollbackCounter) < 1 {
		m.t.Error("Expected call to FakeTxMock.Rollback")
	}
}

type mFakeTxMockSendBatch struct {
	mock               *FakeTxMock
	defaultExpectation *FakeTxMockSendBatchExpectation
	expectations       []*FakeTxMockSendBatchExpectation

	callArgs []*FakeTxMockSendBatchParams
	mutex    sync.RWMutex
}

// FakeTxMockSendBatchExpectation specifies expectation struct of the FakeTx.SendBatch
type FakeTxMockSendBatchExpectation struct {
	mock    *FakeTxMock
	params  *FakeTxMockSendBatchParams
	results *FakeTxMockSendBatchResults
	Counter uint64
}

// FakeTxMockSendBatchParams contains parameters of the FakeTx.SendBatch
type FakeTxMockSendBatchParams struct {
	ctx context.Context
	b   *pgx.Batch
}

// FakeTxMockSendBatchResults contains results of the FakeTx.SendBatch
type FakeTxMockSendBatchResults struct {
	b1 pgx.BatchResults
}

// Expect sets up expected params for FakeTx.SendBatch
func (mmSendBatch *mFakeTxMockSendBatch) Expect(ctx context.Context, b *pgx.Batch) *mFakeTxMockSendBatch {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("FakeTxMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &FakeTxMockSendBatchExpectation{}
	}

	mmSendBatch.defaultExpectation.params = &FakeTxMockSendBatchParams{ctx, b}
	for _, e := range mmSendBatch.expectations {
		if minimock.Equal(e.params, mmSendBatch.defaultExpectation.params) {
			mmSendBatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendBatch.defaultExpectation.params)
		}
	}

	return mmSendBatch
}

// Inspect accepts an inspector function that has same arguments as the FakeTx.SendBatch
func (mmSendBatch *mFakeTxMockSendBatch) Inspect(f func(ctx context.Context, b *pgx.Batch)) *mFakeTxMockSendBatch {
	if mmSendBatch.mock.inspectFuncSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("Inspect function is already set for FakeTxMock.SendBatch")
	}

	mmSendBatch.mock.inspectFuncSendBatch = f

	return mmSendBatch
}

// Return sets up results that will be returned by FakeTx.SendBatch
func (mmSendBatch *mFakeTxMockSendBatch) Return(b1 pgx.BatchResults) *FakeTxMock {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("FakeTxMock.SendBatch mock is already set by Set")
	}

	if mmSendBatch.defaultExpectation == nil {
		mmSendBatch.defaultExpectation = &FakeTxMockSendBatchExpectation{mock: mmSendBatch.mock}
	}
	mmSendBatch.defaultExpectation.results = &FakeTxMockSendBatchResults{b1}
	return mmSendBatch.mock
}

// Set uses given function f to mock the FakeTx.SendBatch method
func (mmSendBatch *mFakeTxMockSendBatch) Set(f func(ctx context.Context, b *pgx.Batch) (b1 pgx.BatchResults)) *FakeTxMock {
	if mmSendBatch.defaultExpectation != nil {
		mmSendBatch.mock.t.Fatalf("Default expectation is already set for the FakeTx.SendBatch method")
	}

	if len(mmSendBatch.expectations) > 0 {
		mmSendBatch.mock.t.Fatalf("Some expectations are already set for the FakeTx.SendBatch method")
	}

	mmSendBatch.mock.funcSendBatch = f
	return mmSendBatch.mock
}

// When sets expectation for the FakeTx.SendBatch which will trigger the result defined by the following
// Then helper
func (mmSendBatch *mFakeTxMockSendBatch) When(ctx context.Context, b *pgx.Batch) *FakeTxMockSendBatchExpectation {
	if mmSendBatch.mock.funcSendBatch != nil {
		mmSendBatch.mock.t.Fatalf("FakeTxMock.SendBatch mock is already set by Set")
	}

	expectation := &FakeTxMockSendBatchExpectation{
		mock:   mmSendBatch.mock,
		params: &FakeTxMockSendBatchParams{ctx, b},
	}
	mmSendBatch.expectations = append(mmSendBatch.expectations, expectation)
	return expectation
}

// Then sets up FakeTx.SendBatch return parameters for the expectation previously defined by the When method
func (e *FakeTxMockSendBatchExpectation) Then(b1 pgx.BatchResults) *FakeTxMock {
	e.results = &FakeTxMockSendBatchResults{b1}
	return e.mock
}

// SendBatch implements service.FakeTx
func (mmSendBatch *FakeTxMock) SendBatch(ctx context.Context, b *pgx.Batch) (b1 pgx.BatchResults) {
	mm_atomic.AddUint64(&mmSendBatch.beforeSendBatchCounter, 1)
	defer mm_atomic.AddUint64(&mmSendBatch.afterSendBatchCounter, 1)

	if mmSendBatch.inspectFuncSendBatch != nil {
		mmSendBatch.inspectFuncSendBatch(ctx, b)
	}

	mm_params := FakeTxMockSendBatchParams{ctx, b}

	// Record call args
	mmSendBatch.SendBatchMock.mutex.Lock()
	mmSendBatch.SendBatchMock.callArgs = append(mmSendBatch.SendBatchMock.callArgs, &mm_params)
	mmSendBatch.SendBatchMock.mutex.Unlock()

	for _, e := range mmSendBatch.SendBatchMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmSendBatch.SendBatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendBatch.SendBatchMock.defaultExpectation.Counter, 1)
		mm_want := mmSendBatch.SendBatchMock.defaultExpectation.params
		mm_got := FakeTxMockSendBatchParams{ctx, b}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendBatch.t.Errorf("FakeTxMock.SendBatch got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendBatch.SendBatchMock.defaultExpectation.results
		if mm_results == nil {
			mmSendBatch.t.Fatal("No results are set for the FakeTxMock.SendBatch")
		}
		return (*mm_results).b1
	}
	if mmSendBatch.funcSendBatch != nil {
		return mmSendBatch.funcSendBatch(ctx, b)
	}
	mmSendBatch.t.Fatalf("Unexpected call to FakeTxMock.SendBatch. %v %v", ctx, b)
	return
}

// SendBatchAfterCounter returns a count of finished FakeTxMock.SendBatch invocations
func (mmSendBatch *FakeTxMock) SendBatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendBatch.afterSendBatchCounter)
}

// SendBatchBeforeCounter returns a count of FakeTxMock.SendBatch invocations
func (mmSendBatch *FakeTxMock) SendBatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendBatch.beforeSendBatchCounter)
}

// Calls returns a list of arguments used in each call to FakeTxMock.SendBatch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendBatch *mFakeTxMockSendBatch) Calls() []*FakeTxMockSendBatchParams {
	mmSendBatch.mutex.RLock()

	argCopy := make([]*FakeTxMockSendBatchParams, len(mmSendBatch.callArgs))
	copy(argCopy, mmSendBatch.callArgs)

	mmSendBatch.mutex.RUnlock()

	return argCopy
}

// MinimockSendBatchDone returns true if the count of the SendBatch invocations corresponds
// the number of defined expectations
func (m *FakeTxMock) MinimockSendBatchDone() bool {
	for _, e := range m.SendBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendBatchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendBatchCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendBatch != nil && mm_atomic.LoadUint64(&m.afterSendBatchCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendBatchInspect logs each unmet expectation
func (m *FakeTxMock) MinimockSendBatchInspect() {
	for _, e := range m.SendBatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to FakeTxMock.SendBatch with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendBatchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendBatchCounter) < 1 {
		if m.SendBatchMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to FakeTxMock.SendBatch")
		} else {
			m.t.Errorf("Expected call to FakeTxMock.SendBatch with params: %#v", *m.SendBatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendBatch != nil && mm_atomic.LoadUint64(&m.afterSendBatchCounter) < 1 {
		m.t.Error("Expected call to FakeTxMock.SendBatch")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *FakeTxMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockBeginInspect()

			m.MinimockBeginFuncInspect()

			m.MinimockCommitInspect()

			m.MinimockConnInspect()

			m.MinimockCopyFromInspect()

			m.MinimockExecInspect()

			m.MinimockLargeObjectsInspect()

			m.MinimockPrepareInspect()

			m.MinimockQueryInspect()

			m.MinimockQueryFuncInspect()

			m.MinimockQueryRowInspect()

			m.MinimockRollbackInspect()

			m.MinimockSendBatchInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *FakeTxMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *FakeTxMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockBeginDone() &&
		m.MinimockBeginFuncDone() &&
		m.MinimockCommitDone() &&
		m.MinimockConnDone() &&
		m.MinimockCopyFromDone() &&
		m.MinimockExecDone() &&
		m.MinimockLargeObjectsDone() &&
		m.MinimockPrepareDone() &&
		m.MinimockQueryDone() &&
		m.MinimockQueryFuncDone() &&
		m.MinimockQueryRowDone() &&
		m.MinimockRollbackDone() &&
		m.MinimockSendBatchDone()
}
